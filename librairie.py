
#from graphics import *
import networkx as nx
import matplotlib.pyplot as plt
import threading
import time 
from itertools import permutations , combinations

class Task :
    def __init__(self, name, writes = None, run = None, reads = None):
        self.name = name
        self.reads = reads
        self.writes = writes
        self.run = run
    
    #affiche les attributs de la classe Task
    def afficher(self):
        print(self.name)
        print(self.writes)
        print(self.run)
        print(self.reads)
    

class TaskSytsem:
    def __init__(self, listeTache, dictionnairePrecedence):
        self.listeTache = listeTache
        self.dictionnairePrecedence = dictionnairePrecedence
    
    
    def afficherListeTache(self):
        for i in range(len(self.listeTache)):
            print(self.listeTache[i].name, end = " ")
    
    #Montrer les dépendences d'une tache
    def getDenpendencies(self, nomTache):
        for key in self.dictionnairePrecedence.keys():
            myStr = " ".join(map(str, self.dictionnairePrecedence.get(key)))
            if (key == nomTache and myStr == ""):
                print("La tache " + nomTache + " ne possède aucune dépendance")
                break
            elif (key == nomTache and not myStr == ""):
                print("Les dépendances de la tache " + nomTache + " sont " + myStr)
                break
            elif (nomTache not in self.dictionnairePrecedence.keys()):
                print("La tache n'existe pas")
                break

          
    def afficherDependencies (self):
         for i in self.dictionnairePrecedence.keys():
            self.getDenpendencies(i)

            
    #Ajouter une dépendence à une tache
    def ajouterPrecedence(self, nomTache, data):
        for key in self.dictionnairePrecedence.keys():
            if (key == nomTache):
                self.dictionnairePrecedence[key].append(data)
                break
            elif (nomTache not in self.dictionnairePrecedence.keys()):
                self.dictionnairePrecedence[nomTache] = data
                break
    
    #Ajouter une tache à la liste de tache
    def ajouterTache(self, tache):
        if tache in self.listeTache:
            print("La tache existe déjà")
        else :
            self.listeTache.append(tache)

    def positionKey(self, tache):
        dictToList = list(self.dictionnairePrecedence)
        return dictToList.index(tache)
            

    #verifie si il existe des taches dans la liste qui ont le même nom
    def existName(self):
        for i in range(len(self.listeTache)):
            for j in range(i+1, len(self.listeTache)):
                if (self.listeTache[i].name == self.listeTache[j].name):
                    print("La tache " + self.listeTache[i].name + " et " + self.listeTache[j].name + " ont le même nom")
                    return True
        return False

    #verifie si on a pas mis deux fois la même tache
    def existTache(self):
        for i in range(len(self.listeTache)):
            for j in range(i + 1, len(self.listeTache)):
                if (self.listeTache[i] == self.listeTache[j]):
                    print("Vous avez mis la même tache " + self.listeTache[j].name)
                    return True
        return False 

    def creerTache(self, nom, writes, reads, run = None):
        newTache = Task(nom, [writes], run, [reads])
        self.listeTache.append(newTache)
    
    def conditionBernstein(self, tache1, tache2):
        for i in tache1.writes:
            for j in tache2.reads:
                if i == j:
                    #print("ne remplis pas les conditions Ecriture " + tache1.name + " et de Lecture " + tache2.name)
                    return False
        for k in tache2.writes:
            for l in tache1.reads:
                if k == l:
                    #print("ne remplis pas les conditions Ecriture " + tache2.name + " et de Lecture " + tache1.name)
                    return False
        for a in tache1.writes:
            for b in tache2.writes:
                if a == b:
                    #print("ne remplis pas les conditions Ecriture " + tache1.name + " et d'Ecriture " + tache2.name)
                    return False
        return True
    
    def comparaisonTache(self, tache):
        dictionnaire = {}
        start = getKey(self.listeTache, tache)
        for i in range(start ,len(self.listeTache)):
            #dictionnaire[i] = {}
            if self.conditionBernstein(tache, self.listeTache[i]) == False and self.listeTache[i] != tache:
                #ajouter(dictionnaire, self.listeTache[i])
                dictionnaire[i] = self.listeTache[i]
        return dictionnaire

    def allBernstein(self):
        dictionnaire = {}
        for i in range (len(self.listeTache)):
            #dictionnaire[i] = {}
            dictionnaire[i] = self.comparaisonTache(self.listeTache[i])
            #ajouter(dictIncompatible, self.comparaisonTache(self.listeTache[i]))
        return dictionnaire

#Supprime les redondances : on se base sur la matrice vue en td 
    def supprimerRedondances(self, dico):
        for i in range (len(dico)):
            for j in range(len(dico.get(i))):
                for k in range(i+1,len(dico)):
                    for l in range (len(dico.get(k))):
                        if dico.get(i).get(j)==dico.get(k).get(l) and (self.listeTache[k]) in dico.get(i).values():
                            dico.get(i).pop(getKey(dico.get(i),dico.get(k).get(l)))
        return dico
    
    #Transforme l'emplacement mémoire de chaque tache par leur nom
    def transformRedondanceName(self, dico):
        newRedondance = {}
        for i in range(len(dico)):
            newRedondance[i] = {}
            for j in range(len(dico.get(i))):
                
                newRedondance[i][j] = dico[i][j].name
        return newRedondance 
   
    """
    def allRoads(self):
        allRoads = []
        for i in range(len(self.redondances(self.conditionBernsteinUltime()))):
            visited = []
            self.dfs(visited, self)
    """        
    
    def run (self,dico):
        threads = []
        start1 = time.perf_counter()
        for tasks in range(len(dico)):

            globals()['t'+str(1)]=threading.Thread(target = dico[tasks].run)
            threads.append(globals()['t'+str(1)])
        for thread in threads:
            thread.start()
            thread.join()
        finish = time.perf_counter()
        print(f'Finished in {round(finish-start1,2)} second(s)')    

    def task_order (self,task,dico):
        for taches in permutations(task):
            r  = all(
                before not in dico[after]
                for before, after in dico[taches]
                if after in dico
            )
            if r:
                return self.dico[taches]
    
   
    # Affichage des taches avec un dessin
    #bonus 2
    def draw(self):
        # Ajoute les taches dans un tableau 
        Taches = []
        maxparra = self.supprimerRedondances(self.allBernstein())
        for i in range(len(maxparra)):
            for j in range(len(maxparra.get(i))):
                Taches.append((self.listeTache[i].name, maxparra.get(i).get(j).name))
                # Creation du dessin 
        G = nx.DiGraph()
        G.add_edges_from(Taches)
        pos = nx.spring_layout(G)
        nx.draw_networkx_nodes(G, pos,node_color = "Green", node_size=400 ,node_shape= "8")
        nx.draw_networkx_edges(G, pos, edgelist=G.edges(), edge_color='black')
        nx.draw_networkx_labels(G, pos)
        plt.show()

#Ajoute des Éléments dans un dictionnaire
def ajouter(dictionnaire, element):
    dictionnaire[len(dictionnaire)] = element

# Permet d'avoir la clé de la tache
def getKey(dico, tache):                                  
    for i in range(len(dico)):
        if dico[i].name == tache.name:
            return i

def dfs(visited,graph,node):  #function for dfs 
        visited = set()  #Set to keep track of visited nodes of graph.
        if node not in visited:
            print (node)
            visited.add(node)
            for neighbour in graph[node]:
                if neighbour not in visited:
                    dfs(visited, graph,neighbour)




exemple = {
        "T1": ["Tsomme"], 
        "T2": ["Tsomme"], 
        "Tsomme": ["T1", "T2"]
    }

exemple2 = {
        "T1" : [],
        "T2" : [],
        "T3" : [],
        "T4" : ["T1", "T2"],
        "T5" : ["T1", "T2"],
        "T6" : ["T3", "T5"],
        "T7" : ["T6"],
        "T8" : ["T4", "T7"]
    }


exemple3 = {
        "T1" : [],
        "T2" : [],
        "T3" : ["T1", "T2"],
        "T4" : ["T1", "T2"],
        "T5" : ["T1", "T2"],
        "T6" : ["T4"],
        "T7" : ["T2", "T3", "T4", "T5"],
        "T8" : ["T1", "T3", "T4", "T6"]
    }
exemple4 = {
    "T1" : ["T3","T4","T5","T8"],
    "T2" : ["T3","T4","T5","T7","T8"],
    "T3" : ["T7","T8"],
    "T4" : ["T7","T6","T8"],
    "T5" : ["T7"],
    "T6" : ["T8"],
    "T7" : [],
    "T8" : []


}    

global X  
global Y 
global Z 

def runT1():
    global X
    X = 1
    print("X = "+ str(X))
    print('Sleeping 1 second...')
    time.sleep(1)
    print('Done Sleeping...')
        
def runT2():
    global Y
    Y = 2
    print("Y = "+ str(Y))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')
        
def runT3():
    global Z, Y, X
    Z = Y + X
    print("Z = " + str(Z))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')

def runT4():
    global Z, Y , X
    Z = Y * X
    print("Z = " + str(Z))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')

def runT5():
    global Y , X , Z
    Z = Y / X
    print("Z = " + str(Z))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')


def runT6():
    global Y, Z
    Y = Y + Z
    print("Y = "+ str(Y))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')

def runT7():
    global Y , X , Z
    X = X + Y *2
    print("X = "+ str(X))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')

def runT8():
    global Y , X , Z
    print("X = "+ str(X))
    print("Y = "+ str(Y))
    print("Z = "+ str(Z))
    print('Sleeping 2 second...')
    time.sleep(2)
    print('Done Sleeping...')

"""
t1 = Task("T1", ["X"], runT1, [""])
t2 = Task("T2", ["Y"], runT2, [""])
t3 = Task("Tsomme", ["Z"], runT3, ["X","Y"])
"""
"""
t1 = Task("T1", ["G"], None, ["A", "B"])
t2 = Task("T2", ["H"], None, ["C", "D"])
t3 = Task("T3", ["I"], None, ["E","F"])
t4 = Task("T4", ["J"], None, ["G","H"])
t5 = Task("T5", ["K"], None, ["G","H"])
t6 = Task("T6", ["L"], None, ["I","K"])
t7 = Task("T7", ["M"], None, ["L"])
t8 = Task("T8", ["N"], None, ["J","M"])
"""

t1 = Task("T1", ["M3"], runT1, ["M1", "M2"])
t2 = Task("T2", ["M4"], runT2, ["M1"])
t3 = Task("T3", ["M1"], runT3, ["M3","M4"])
t4 = Task("T4", ["M5"], runT4, ["M3","M4"])
t5 = Task("T5", ["M2"], runT5, ["M4"])
t6 = Task("T6", ["M5"], runT6, ["M5"])
t7 = Task("T7", ["M4"], runT7, ["M1", "M2", "M4"])
t8 = Task("T8", ["M5"], runT8, ["M1","M3"])

#listeTache1 = [t1, t2, t3]
listeTache = [t1, t2, t3, t4, t5, t6,t7,t8]

s1 = TaskSytsem(listeTache, exemple3)

   



                
#print(s1.conditionBernsteinUltime())
#s1.getDenpendencies("T4")
#print(s1.comparaisonTache(t1))
#print(s1.allBernstein())
redondance = s1.supprimerRedondances(s1.allBernstein())

newRedondance = s1.transformRedondanceName(redondance)
print(newRedondance)
#s1.task_order(listeTache,exemple3)
#visited = set()
#dfs(visited, exemple4,"T1")
#s1.run(listeTache)
#dfs(visited, maxparra, 0)
#dfs(visited, s1.conditionBernsteinUltime(),5)
#dfs(visited, s1.redondances(s1.conditionBernsteinUltime()), 5)
#s1.afficherRedondanceName(maxparra)
#bfs(visited, s1.conditionBernsteinUltime(), 'T8')         
