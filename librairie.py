
#from graphics import *
#import networkx as nx
#import matplotlib.pyplot as plt

class Task :
    def __init__(self, name, writes = None, run = None, reads = None):
        self.name = name
        self.reads = reads
        self.writes = writes
        self.run = run
    
    #affiche les attributs de la classe Task
    def afficher(self):
        print(self.name)
        print(self.writes)
        print(self.run)
        print(self.reads)
    

class TaskSytsem:
    def __init__(self, listeTache, dictionnairePrecedence):
        self.listeTache = listeTache
        self.dictionnairePrecedence = dictionnairePrecedence
    
    
    def afficherListeTache(self):
        for i in range(len(self.listeTache)):
            print(self.listeTache[i].name, end = " ")
    
    #Montrer les dépendences d'une tache
    def getDenpendencies(self, nomTache):
        for key in self.dictionnairePrecedence.keys():
            myStr = " ".join(map(str, self.dictionnairePrecedence.get(key)))
            if (key == nomTache and myStr == ""):
                print("La tache " + nomTache + " ne possède aucune dépendance")
                break
            elif (key == nomTache and not myStr == ""):
                print("Les dépendances de la tache " + nomTache + " sont " + myStr)
                break
            elif (nomTache not in self.dictionnairePrecedence.keys()):
                print("La tache n'existe pas")
                break

          
    def afficherDependencies (self):
         for i in self.dictionnairePrecedence.keys():
            self.getDenpendencies(i)

            
    #Ajouter une dépendence à une tache
    def ajouterPrecedence(self, nomTache, data):
        for key in self.dictionnairePrecedence.keys():
            if (key == nomTache):
                self.dictionnairePrecedence[key].append(data)
                break
            elif (nomTache not in self.dictionnairePrecedence.keys()):
                self.dictionnairePrecedence[nomTache] = data
                break
    
    #Ajouter une tache à la liste de tache
    def ajouterTache(self, tache):
        if tache in self.listeTache:
            print("La tache existe déjà")
        else :
            self.listeTache.append(tache)

    def positionKey(self, tache):
        dictToList = list(self.dictionnairePrecedence)
        return dictToList.index(tache)
            

    #verifie si il existe des taches dans la liste qui ont le même nom
    def sameName(self):
        for i in range(len(self.listeTache)):
            for j in range(i+1, len(self.listeTache)):
                if (self.listeTache[i].name == self.listeTache[j].name):
                    print("La tache " + self.listeTache[i].name + " et " + self.listeTache[j].name + " ont le même nom")
                    return True
        return False

    #verifie si on a pas mis deux fois la même tache
    def existTache(self):
        for i in range(len(self.listeTache)):
            for j in range(i + 1, len(self.listeTache)):
                if (self.listeTache[i] == self.listeTache[j]):
                    print("Vous avez mis la même tache " + self.listeTache[j].name)
                    return True
        return False 

    def creerTache(self, nom, writes, reads, run = None):
        newTache = Task(nom, [writes], run, [reads])
        self.listeTache.append(newTache)
    
    def conditionBernstein(self, tache1, tache2):
        for i in tache1.writes:
            for j in tache2.reads:
                if i == j:
                    #print("ne remplis pas les conditions Ecriture " + tache1.name + " et de Lecture " + tache2.name)
                    return False
        for k in tache2.writes:
            for l in tache1.reads:
                if k == l:
                    #print("ne remplis pas les conditions Ecriture " + tache2.name + " et de Lecture " + tache1.name)
                    return False
        for a in tache1.writes:
            for b in tache2.writes:
                if a == b:
                    #print("ne remplis pas les conditions Ecriture " + tache1.name + " et d'Ecriture " + tache2.name)
                    return False
        return True
    
    def conditionBernsteinTotal(self, tache):
        dictIncompatible = {}
        start = getKey(self.listeTache, tache)
        for i in range(start ,len(self.listeTache)):
            if self.conditionBernstein(tache, self.listeTache[i]) == False and self.listeTache[i] != tache:
                addElement(dictIncompatible, self.listeTache[i])
        return dictIncompatible

    def conditionBernsteinUltime(self):
        dictIncompatible = {}
        for i in range (len(self.listeTache)):
            addElement(dictIncompatible, self.conditionBernsteinTotal(self.listeTache[i]))
        return dictIncompatible

#Supprime les redondances : on se base sur la matrice vue en td 
    def redondances(self, dico):
        for i in range (len(dico)):
            for j in range(len(dico.get(i))):
                for k in range(i+1,len(dico)):
                    for l in range (len(dico.get(k))):
                        if dico.get(i).get(j)==dico.get(k).get(l) and (self.listeTache[k]) in dico.get(i).values():
                            dico.get(i).pop(getKey(dico.get(i),dico.get(k).get(l)))
        return dico

    


      
    

    
    # Affichage des taches avec un dessin
    """
    def draw(self):
        # Ajoute les taches dans un tableau 
        Taches = []
        maxparra = self.redondances(self.conditionBernsteinUltime())
        for i in range(len(maxparra)):
            for j in range(len(maxparra.get(i))):
                Taches.append((self.listeTache[i].name, maxparra.get(i).get(j).name))
                # Creation du dessin 
        G = nx.DiGraph()
        G.add_edges_from(Taches)
        pos = nx.spring_layout(G)
        nx.draw_networkx_nodes(G, pos,node_color = "Green", node_size=400 ,node_shape= "8")
        nx.draw_networkx_edges(G, pos, edgelist=G.edges(), edge_color='black')
        nx.draw_networkx_labels(G, pos)
        plt.show()
    """
    #Ajoute des Éléments dans un dictionnaire
def addElement(dictionnaire, element):
    dictionnaire[len(dictionnaire)] = element

def getKey(dico, tache):                                   # Retourne la clé de la valeur passé en parametre
    for i in range(len(dico)):
        if dico[i].name == tache.name:
            return i



   



exemple = {
        "T1": ["Tsomme"], 
        "T2": ["Tsomme"], 
        "Tsomme": ["T1", "T2"]
    }

exemple2 = {
        "T1" : [],
        "T2" : [],
        "T3" : [],
        "T4" : ["T1", "T2"],
        "T5" : ["T1", "T2"],
        "T6" : ["T3", "T5"],
        "T7" : ["T6"],
        "T8" : ["T4", "T7"]
    }


exemple3 = {
        "T1" : [],
        "T2" : [],
        "T3" : ["T1", "T2"],
        "T4" : ["T1", "T2"],
        "T5" : ["T1", "T2"],
        "T6" : ["T4"],
        "T7" : ["T2", "T3", "T4", "T5"],
        "T8" : ["T1", "T3", "T4", "T6"]
    }


def runT1():
    global X
    X = 1
        
def runT2():
    global Y
    Y = 2
        
def runT3():
    global X, Y, Z
    Z = Y + X

    """
    t1 = Task("T1", ["X"], None, [""])
    t2 = Task("T2", ["Y"], None, [""])
    t3 = Task("Tsomme", ["Z"], None, ["X","Y"])
    """
    """
    t1 = Task("T1", ["G"], None, ["A", "B"])
    t2 = Task("T2", ["H"], None, ["C", "D"])
    t3 = Task("T3", ["I"], None, ["E","F"])
    t4 = Task("T4", ["J"], None, ["G","H"])
    t5 = Task("T5", ["K"], None, ["G","H"])
    t6 = Task("T6", ["L"], None, ["I","K"])
    t7 = Task("T7", ["M"], None, ["L"])
    t8 = Task("T8", ["N"], None, ["J","M"])
    """

t1 = Task("T1", ["M3"], None, ["M1", "M2"])
t2 = Task("T2", ["M4"], None, ["M1"])
t3 = Task("T3", ["M1"], None, ["M3","M4"])
t4 = Task("T4", ["M5"], None, ["M3","M4"])
t5 = Task("T5", ["M2"], None, ["M4"])
t6 = Task("T6", ["M5"], None, ["M5"])
t7 = Task("T7", ["M4"], None, ["M1", "M2", "M4"])
t8 = Task("T8", ["M5"], None, ["M1","M3"])

    #listeTache1 = [t1, t2, t3]
listeTache = [t1, t2, t3, t4, t5, t6, t7, t8]

s1 = TaskSytsem(listeTache, exemple3)
    #print(conditionBernsteinUltime(s1))
    #print(redondances(conditionBernsteinUltime(s1)))
    #print(getKey(s1.listeTache, t7))
    #print(conditionBernsteinTotal(t1, s1))
    #print(conditionBernsteinUltime(s1))
    #maxparra = s1.redondances(s1.conditionBernsteinUltime())
    #print(maxparra)
    #print(s1.conditionBernsteinUltime())

graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}





 
# Driver Code
#print("Following is the Breadth-First Search")
#bfs(visited, exemple3, 'T5')    # function calling 
visited = set() # Set to keep track of visited nodes of graph.

def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node)
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

# Driver Code
print("Following is the Depth-First Search")
dfs(visited, s1.conditionBernsteinUltime(), 0)
#bfs(visited, s1.conditionBernsteinUltime(), 'T8')         